<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="js/dat.gui.min.js"></script>
        <script src="js/ammo.js"></script>
        <script src="js/cannon.js"></script>
        <script src="js/Oimo.js"></script>
        <script src="js/earcut.min.js"></script>
        <script src="babylon.js"></script>
        <script src="js/babylonjs.materials.min.js"></script>
        <script src="js/babylonjs.proceduralTextures.min.js"></script>
        <script src="js/babylonjs.postProcess.min.js"></script>
        <script src="js/babylonjs.loaders.js"></script>
        <script src="js/babylonjs.serializers.min.js"></script>
        <script src="js/babylon.gui.min.js"></script>
        <script src="js/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
    let elevatorStates = "stop";
let targetFloor = null;
let floorHeights = [0, 2, 4, 6, 8, 10]; // G, 1, 2, 3, 4, 5 floor Y positions
let lift;
let doorLeft
 let doorRight
 let door
 let doorOpen = false; // Track door state
   // Elevator States
    const ELEVATOR_STATES = {
        IDLE: "Idle",
        MOVING_UP: "Moving Up",
        MOVING_DOWN: "Moving Down",
        ERROR: "Error",
        POWERED_OFF: "Powered Off"
    };

    let elevatorState = ELEVATOR_STATES.IDLE;
    let monitoringData = {
        motorTemp: 25,
        ropeTension: 100,
        doorStatus: "Closed",
        position: 0
    };

                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = function () {
    // This creates a basic Babylon Scene object (non-mesh)
    var scene = new BABYLON.Scene(engine);

    // This creates and positions a free camera (non-mesh)
    camera = new BABYLON.ArcRotateCamera("camera1", 0, 0, 0, new BABYLON.Vector3(0, 3, 0), scene);
			
            camera.setPosition(new BABYLON.Vector3(20, 5, 5));
            camera.attachControl(canvas, true);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new BABYLON.PointLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 1.0;
    

    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
			var gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("myUI");
		
		var inspector = BABYLON.GUI.Button.CreateSimpleButton("inspector", "inspector");
    inspector.top = "30%";
	inspector.left = "43%";
	inspector.width = "90px";
	inspector.height = "40px";
	inspector.color = "white";
	inspector.background = "transparent";
	inspector.cornerRadius = 5;
	inspector.onPointerClickObservable.add(function () {
	scene.debugLayer.show();
		
	})

	gui.addControl(inspector);

    

    // Our built-in 'sphere' shape.
    BABYLON.SceneLoader.ImportMesh("","scenes/", "lift_model.glb", scene, function (meshes) { 
         lift = meshes[0]
        lift.scaling = new BABYLON.Vector3(2,2,2)
        lift.position.y = 0; // Start at ground floor
        let elevatorY = 0;
         doorLeft = scene.getNodeByName("Object_84");
     doorRight = scene.getNodeByName("Object_86");
     doorLeft.dispose(); 
     doorRight.dispose(); 

    if (doorLeft && doorRight) {
        console.log("Doors loaded!");
    }
    door.setParent(lift);

    })
    
    BABYLON.SceneLoader.ImportMesh("","scenes/", "lift_door_.glb", scene, function (meshes) { 
          door = meshes[0]
        //door.position.x = 2
        door.scaling = new BABYLON.Vector3(2,2,2)
        let liftdoorLeft = scene.getNodeByName("right-door_Cube.001_primitive0");
            let rightdoorLeft = scene.getNodeByName("right-door_Cube.001_primitive1");
            liftdoorLeft.position.x = 80
            rightdoorLeft.position.x = -80
      //  lift.setParent(door)
    })

    

var gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("myUI");

const floorLabels = ["G", "1", "2", "3", "4", "5"];

floorLabels.forEach((label, index) => {
    let floorBtn = BABYLON.GUI.Button.CreateSimpleButton(`floor${label}`, `${label}`);
    floorBtn.width = "50px";
    floorBtn.height = "40px";
    floorBtn.color = "white";
    floorBtn.background = "blue";
    floorBtn.top = `${10 + (index * 50)}px`;
    floorBtn.left = "-600px";
    floorBtn.cornerRadius = 20;
    floorBtn.onPointerClickObservable.add(() => {
        targetFloor = index;
        elevatorStates = "start";
    });
    gui.addControl(floorBtn);
});


        // GUI Panel for Monitoring
        const guiTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        const panel = new BABYLON.GUI.StackPanel();
        panel.width = "220px";
        panel.top = "-350px";
        panel.left = "-150px";
        panel.height = "250px";
        panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        guiTexture.addControl(panel);

        let header = new BABYLON.GUI.TextBlock();
        header.text = "Elevator Monitoring";
        header.height = "40px";
        header.color = "white";
        header.fontSize = 20;
        panel.addControl(header);

        // Data fields
        let stateText = new BABYLON.GUI.TextBlock();
        let tempText = new BABYLON.GUI.TextBlock();
        let tensionText = new BABYLON.GUI.TextBlock();
        let doorText = new BABYLON.GUI.TextBlock();
        let posText = new BABYLON.GUI.TextBlock();

        [stateText, tempText, tensionText, doorText, posText].forEach(txt => {
            txt.height = "30px";
            txt.color = "white";
            txt.fontSize = 16;
            panel.addControl(txt);
        });

// Elevator Movement Logic
scene.onBeforeRenderObservable.add(() => {
    if (elevatorStates === "start" && lift && targetFloor !== null) {
        let targetY = floorHeights[targetFloor];

        // Ensure ground floor can trigger movement
        if (Math.abs(lift.position.y - targetY) > 0.02) {
            let direction = targetY > lift.position.y ? 0.02 : -0.02;
            lift.position.y += direction;
            let liftdoorLeft = scene.getNodeByName("right-door_Cube.001_primitive0");
            let rightdoorLeft = scene.getNodeByName("right-door_Cube.001_primitive1");
            liftdoorLeft.position.x = 0
            rightdoorLeft.position.x = 0
            console.log("check")
        } else {
            lift.position.y = targetY; 
            elevatorStates = "stop";
            targetFloor = null;
            let liftdoorLeft = scene.getNodeByName("right-door_Cube.001_primitive0");
            let rightdoorLeft = scene.getNodeByName("right-door_Cube.001_primitive1");
            liftdoorLeft.position.x = 80
            rightdoorLeft.position.x = -80
        }
    }
     updateMonitoringData();
            stateText.text = "State: " + elevatorState;
            tempText.text = "Motor Temp: " + monitoringData.motorTemp.toFixed(1) + "Â°C";
            tensionText.text = "Rope Tension: " + monitoringData.ropeTension.toFixed(1) + " N";
            doorText.text = "Door: " + monitoringData.doorStatus;
            posText.text = "Position: " + monitoringData.position.toFixed(2) + " m";
});

 function updateState(newState) {
        elevatorState = newState;
    }

    function updateMonitoringData() {
        monitoringData.motorTemp = 25 + Math.random() * 5;
        monitoringData.ropeTension = 95 + Math.random() * 10;
        monitoringData.position = lift ? lift.position.y : 0;
        monitoringData.doorStatus = doorOpen ? "Open" : "Closed";
    }

    //const scene = createScene();

    // Elevator Movement
    scene.onBeforeRenderObservable.add(() => {
        if (elevatorState !== ELEVATOR_STATES.POWERED_OFF && 
            elevatorState !== ELEVATOR_STATES.ERROR &&
            targetFloor !== null) {
            
            let targetY = floorHeights[targetFloor];

            if (Math.abs(lift.position.y - targetY) > 0.02) {
                let direction = targetY > lift.position.y ? 0.02 : -0.02;
                lift.position.y += direction;
                updateState(direction > 0 ? ELEVATOR_STATES.MOVING_UP : ELEVATOR_STATES.MOVING_DOWN);
            } else {
                lift.position.y = targetY;
                targetFloor = null;
                updateState(ELEVATOR_STATES.IDLE);
            }
        }
    });
scene.clearColor = new BABYLON.Color3(0.7, 0.7, 0.8);
    return scene;
};


                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene
                    });

                    // Resize
                      window.addEventListener("keydown", (event) => {
        if (event.key >= "1" && event.key <= "4") {
            targetFloor = parseInt(event.key) - 1;
        }
    });
        </script>
    </body>
</html>
